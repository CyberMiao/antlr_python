# Generated from E:/work/compile/antlr-python/MIDL.g4 by ANTLR 4.13.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,45,251,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,
        7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,1,0,1,0,5,
        0,55,8,0,10,0,12,0,58,9,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,3,1,68,
        8,1,1,2,1,2,1,2,1,2,1,2,5,2,75,8,2,10,2,12,2,78,9,2,1,2,1,2,1,3,
        1,3,1,3,3,3,85,8,3,1,4,1,4,1,4,1,4,1,4,1,4,1,5,1,5,1,5,1,5,5,5,97,
        8,5,10,5,12,5,100,9,5,1,6,1,6,1,6,3,6,105,8,6,1,7,3,7,108,8,7,1,
        7,1,7,1,7,5,7,113,8,7,10,7,12,7,116,9,7,1,8,1,8,1,8,1,8,1,8,3,8,
        123,8,8,1,9,1,9,1,10,1,10,3,10,129,8,10,1,11,1,11,1,11,1,11,1,11,
        3,11,136,8,11,1,11,3,11,139,8,11,1,12,1,12,1,12,3,12,144,8,12,1,
        12,1,12,1,12,3,12,149,8,12,1,12,1,12,1,12,1,12,3,12,155,8,12,1,12,
        3,12,158,8,12,1,13,1,13,1,13,5,13,163,8,13,10,13,12,13,166,9,13,
        1,14,1,14,3,14,170,8,14,1,15,1,15,1,15,3,15,175,8,15,1,16,1,16,1,
        16,1,16,1,16,1,16,3,16,183,8,16,1,17,1,17,1,17,1,17,5,17,189,8,17,
        10,17,12,17,192,9,17,1,17,1,17,1,18,1,18,1,18,5,18,199,8,18,10,18,
        12,18,202,9,18,1,19,1,19,1,19,5,19,207,8,19,10,19,12,19,210,9,19,
        1,20,1,20,1,20,5,20,215,8,20,10,20,12,20,218,9,20,1,21,1,21,1,21,
        5,21,223,8,21,10,21,12,21,226,9,21,1,22,1,22,1,22,5,22,231,8,22,
        10,22,12,22,234,9,22,1,23,1,23,1,23,5,23,239,8,23,10,23,12,23,242,
        9,23,1,24,3,24,245,8,24,1,24,1,24,1,25,1,25,1,25,0,0,26,0,2,4,6,
        8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,
        0,8,1,0,10,12,1,0,13,14,1,0,15,16,1,0,31,32,1,0,33,34,1,0,35,37,
        2,0,33,34,38,38,1,0,40,44,260,0,52,1,0,0,0,2,67,1,0,0,0,4,69,1,0,
        0,0,6,84,1,0,0,0,8,86,1,0,0,0,10,98,1,0,0,0,12,104,1,0,0,0,14,107,
        1,0,0,0,16,122,1,0,0,0,18,124,1,0,0,0,20,128,1,0,0,0,22,138,1,0,
        0,0,24,157,1,0,0,0,26,159,1,0,0,0,28,169,1,0,0,0,30,171,1,0,0,0,
        32,176,1,0,0,0,34,184,1,0,0,0,36,195,1,0,0,0,38,203,1,0,0,0,40,211,
        1,0,0,0,42,219,1,0,0,0,44,227,1,0,0,0,46,235,1,0,0,0,48,244,1,0,
        0,0,50,248,1,0,0,0,52,56,3,2,1,0,53,55,3,2,1,0,54,53,1,0,0,0,55,
        58,1,0,0,0,56,54,1,0,0,0,56,57,1,0,0,0,57,59,1,0,0,0,58,56,1,0,0,
        0,59,60,5,0,0,1,60,1,1,0,0,0,61,62,3,6,3,0,62,63,5,1,0,0,63,68,1,
        0,0,0,64,65,3,4,2,0,65,66,5,1,0,0,66,68,1,0,0,0,67,61,1,0,0,0,67,
        64,1,0,0,0,68,3,1,0,0,0,69,70,5,2,0,0,70,71,5,45,0,0,71,72,5,3,0,
        0,72,76,3,2,1,0,73,75,3,2,1,0,74,73,1,0,0,0,75,78,1,0,0,0,76,74,
        1,0,0,0,76,77,1,0,0,0,77,79,1,0,0,0,78,76,1,0,0,0,79,80,5,4,0,0,
        80,5,1,0,0,0,81,85,3,8,4,0,82,83,5,5,0,0,83,85,5,45,0,0,84,81,1,
        0,0,0,84,82,1,0,0,0,85,7,1,0,0,0,86,87,5,5,0,0,87,88,5,45,0,0,88,
        89,5,3,0,0,89,90,3,10,5,0,90,91,5,4,0,0,91,9,1,0,0,0,92,93,3,12,
        6,0,93,94,3,26,13,0,94,95,5,1,0,0,95,97,1,0,0,0,96,92,1,0,0,0,97,
        100,1,0,0,0,98,96,1,0,0,0,98,99,1,0,0,0,99,11,1,0,0,0,100,98,1,0,
        0,0,101,105,3,14,7,0,102,105,3,16,8,0,103,105,3,8,4,0,104,101,1,
        0,0,0,104,102,1,0,0,0,104,103,1,0,0,0,105,13,1,0,0,0,106,108,5,6,
        0,0,107,106,1,0,0,0,107,108,1,0,0,0,108,109,1,0,0,0,109,114,5,45,
        0,0,110,111,5,6,0,0,111,113,5,45,0,0,112,110,1,0,0,0,113,116,1,0,
        0,0,114,112,1,0,0,0,114,115,1,0,0,0,115,15,1,0,0,0,116,114,1,0,0,
        0,117,123,3,18,9,0,118,123,3,20,10,0,119,123,5,7,0,0,120,123,5,8,
        0,0,121,123,5,9,0,0,122,117,1,0,0,0,122,118,1,0,0,0,122,119,1,0,
        0,0,122,120,1,0,0,0,122,121,1,0,0,0,123,17,1,0,0,0,124,125,7,0,0,
        0,125,19,1,0,0,0,126,129,3,22,11,0,127,129,3,24,12,0,128,126,1,0,
        0,0,128,127,1,0,0,0,129,21,1,0,0,0,130,139,7,1,0,0,131,139,7,2,0,
        0,132,133,5,15,0,0,133,136,5,15,0,0,134,136,5,17,0,0,135,132,1,0,
        0,0,135,134,1,0,0,0,136,139,1,0,0,0,137,139,5,18,0,0,138,130,1,0,
        0,0,138,131,1,0,0,0,138,135,1,0,0,0,138,137,1,0,0,0,139,23,1,0,0,
        0,140,141,5,19,0,0,141,144,5,13,0,0,142,144,5,20,0,0,143,140,1,0,
        0,0,143,142,1,0,0,0,144,158,1,0,0,0,145,146,5,19,0,0,146,149,5,15,
        0,0,147,149,5,21,0,0,148,145,1,0,0,0,148,147,1,0,0,0,149,158,1,0,
        0,0,150,151,5,19,0,0,151,152,5,15,0,0,152,155,5,15,0,0,153,155,5,
        22,0,0,154,150,1,0,0,0,154,153,1,0,0,0,155,158,1,0,0,0,156,158,5,
        23,0,0,157,143,1,0,0,0,157,148,1,0,0,0,157,154,1,0,0,0,157,156,1,
        0,0,0,158,25,1,0,0,0,159,164,3,28,14,0,160,161,5,24,0,0,161,163,
        3,28,14,0,162,160,1,0,0,0,163,166,1,0,0,0,164,162,1,0,0,0,164,165,
        1,0,0,0,165,27,1,0,0,0,166,164,1,0,0,0,167,170,3,30,15,0,168,170,
        3,32,16,0,169,167,1,0,0,0,169,168,1,0,0,0,170,29,1,0,0,0,171,174,
        5,45,0,0,172,173,5,25,0,0,173,175,3,36,18,0,174,172,1,0,0,0,174,
        175,1,0,0,0,175,31,1,0,0,0,176,177,5,45,0,0,177,178,5,26,0,0,178,
        179,3,36,18,0,179,182,5,27,0,0,180,181,5,25,0,0,181,183,3,34,17,
        0,182,180,1,0,0,0,182,183,1,0,0,0,183,33,1,0,0,0,184,185,5,26,0,
        0,185,190,3,36,18,0,186,187,5,24,0,0,187,189,3,36,18,0,188,186,1,
        0,0,0,189,192,1,0,0,0,190,188,1,0,0,0,190,191,1,0,0,0,191,193,1,
        0,0,0,192,190,1,0,0,0,193,194,5,27,0,0,194,35,1,0,0,0,195,200,3,
        38,19,0,196,197,5,28,0,0,197,199,3,38,19,0,198,196,1,0,0,0,199,202,
        1,0,0,0,200,198,1,0,0,0,200,201,1,0,0,0,201,37,1,0,0,0,202,200,1,
        0,0,0,203,208,3,40,20,0,204,205,5,29,0,0,205,207,3,40,20,0,206,204,
        1,0,0,0,207,210,1,0,0,0,208,206,1,0,0,0,208,209,1,0,0,0,209,39,1,
        0,0,0,210,208,1,0,0,0,211,216,3,42,21,0,212,213,5,30,0,0,213,215,
        3,42,21,0,214,212,1,0,0,0,215,218,1,0,0,0,216,214,1,0,0,0,216,217,
        1,0,0,0,217,41,1,0,0,0,218,216,1,0,0,0,219,224,3,44,22,0,220,221,
        7,3,0,0,221,223,3,44,22,0,222,220,1,0,0,0,223,226,1,0,0,0,224,222,
        1,0,0,0,224,225,1,0,0,0,225,43,1,0,0,0,226,224,1,0,0,0,227,232,3,
        46,23,0,228,229,7,4,0,0,229,231,3,46,23,0,230,228,1,0,0,0,231,234,
        1,0,0,0,232,230,1,0,0,0,232,233,1,0,0,0,233,45,1,0,0,0,234,232,1,
        0,0,0,235,240,3,48,24,0,236,237,7,5,0,0,237,239,3,48,24,0,238,236,
        1,0,0,0,239,242,1,0,0,0,240,238,1,0,0,0,240,241,1,0,0,0,241,47,1,
        0,0,0,242,240,1,0,0,0,243,245,7,6,0,0,244,243,1,0,0,0,244,245,1,
        0,0,0,245,246,1,0,0,0,246,247,3,50,25,0,247,49,1,0,0,0,248,249,7,
        7,0,0,249,51,1,0,0,0,28,56,67,76,84,98,104,107,114,122,128,135,138,
        143,148,154,157,164,169,174,182,190,200,208,216,224,232,240,244
    ]

class MIDLParser ( Parser ):

    grammarFileName = "MIDL.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "';'", "'module '", "'{'", "'}'", "'struct '", 
                     "'::'", "'char '", "'string '", "'boolean '", "'float '", 
                     "'double '", "'long double '", "'short '", "'int16 '", 
                     "'long '", "'int32 '", "'int64 '", "'int8 '", "'unsigned '", 
                     "'uint16 '", "'uint32 '", "'uint64 '", "'uint8 '", 
                     "','", "'='", "'['", "']'", "'|'", "'^'", "'&'", "'>>'", 
                     "'<<'", "'+'", "'-'", "'*'", "'/'", "'%'", "'~'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "WS", "INTEGER", 
                      "FLOATING_PT", "CHAR", "STRING", "BOOLEAN", "ID" ]

    RULE_specification = 0
    RULE_definition = 1
    RULE_module = 2
    RULE_type_decl = 3
    RULE_struct_type = 4
    RULE_member_list = 5
    RULE_type_spec = 6
    RULE_scoped_name = 7
    RULE_base_type_spec = 8
    RULE_floating_pt_type = 9
    RULE_integer_type = 10
    RULE_signed_int = 11
    RULE_unsigned_int = 12
    RULE_declarators = 13
    RULE_declarator = 14
    RULE_simple_declarator = 15
    RULE_array_declarator = 16
    RULE_exp_list = 17
    RULE_or_expr = 18
    RULE_xor_expr = 19
    RULE_and_expr = 20
    RULE_shift_expr = 21
    RULE_add_expr = 22
    RULE_mult_expr = 23
    RULE_unary_expr = 24
    RULE_literal = 25

    ruleNames =  [ "specification", "definition", "module", "type_decl", 
                   "struct_type", "member_list", "type_spec", "scoped_name", 
                   "base_type_spec", "floating_pt_type", "integer_type", 
                   "signed_int", "unsigned_int", "declarators", "declarator", 
                   "simple_declarator", "array_declarator", "exp_list", 
                   "or_expr", "xor_expr", "and_expr", "shift_expr", "add_expr", 
                   "mult_expr", "unary_expr", "literal" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    WS=39
    INTEGER=40
    FLOATING_PT=41
    CHAR=42
    STRING=43
    BOOLEAN=44
    ID=45

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class SpecificationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def definition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MIDLParser.DefinitionContext)
            else:
                return self.getTypedRuleContext(MIDLParser.DefinitionContext,i)


        def EOF(self):
            return self.getToken(MIDLParser.EOF, 0)

        def getRuleIndex(self):
            return MIDLParser.RULE_specification

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpecification" ):
                listener.enterSpecification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpecification" ):
                listener.exitSpecification(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSpecification" ):
                return visitor.visitSpecification(self)
            else:
                return visitor.visitChildren(self)




    def specification(self):

        localctx = MIDLParser.SpecificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_specification)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 52
            self.definition()
            self.state = 56
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==2 or _la==5:
                self.state = 53
                self.definition()
                self.state = 58
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 59
            self.match(MIDLParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_decl(self):
            return self.getTypedRuleContext(MIDLParser.Type_declContext,0)


        def module(self):
            return self.getTypedRuleContext(MIDLParser.ModuleContext,0)


        def getRuleIndex(self):
            return MIDLParser.RULE_definition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefinition" ):
                listener.enterDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefinition" ):
                listener.exitDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefinition" ):
                return visitor.visitDefinition(self)
            else:
                return visitor.visitChildren(self)




    def definition(self):

        localctx = MIDLParser.DefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_definition)
        try:
            self.state = 67
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [5]:
                self.enterOuterAlt(localctx, 1)
                self.state = 61
                self.type_decl()
                self.state = 62
                self.match(MIDLParser.T__0)
                pass
            elif token in [2]:
                self.enterOuterAlt(localctx, 2)
                self.state = 64
                self.module()
                self.state = 65
                self.match(MIDLParser.T__0)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ModuleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(MIDLParser.ID, 0)

        def definition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MIDLParser.DefinitionContext)
            else:
                return self.getTypedRuleContext(MIDLParser.DefinitionContext,i)


        def getRuleIndex(self):
            return MIDLParser.RULE_module

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterModule" ):
                listener.enterModule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitModule" ):
                listener.exitModule(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitModule" ):
                return visitor.visitModule(self)
            else:
                return visitor.visitChildren(self)




    def module(self):

        localctx = MIDLParser.ModuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_module)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 69
            self.match(MIDLParser.T__1)
            self.state = 70
            self.match(MIDLParser.ID)
            self.state = 71
            self.match(MIDLParser.T__2)
            self.state = 72
            self.definition()
            self.state = 76
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==2 or _la==5:
                self.state = 73
                self.definition()
                self.state = 78
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 79
            self.match(MIDLParser.T__3)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Type_declContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def struct_type(self):
            return self.getTypedRuleContext(MIDLParser.Struct_typeContext,0)


        def ID(self):
            return self.getToken(MIDLParser.ID, 0)

        def getRuleIndex(self):
            return MIDLParser.RULE_type_decl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType_decl" ):
                listener.enterType_decl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType_decl" ):
                listener.exitType_decl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitType_decl" ):
                return visitor.visitType_decl(self)
            else:
                return visitor.visitChildren(self)




    def type_decl(self):

        localctx = MIDLParser.Type_declContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_type_decl)
        try:
            self.state = 84
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 81
                self.struct_type()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 82
                self.match(MIDLParser.T__4)
                self.state = 83
                self.match(MIDLParser.ID)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Struct_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(MIDLParser.ID, 0)

        def member_list(self):
            return self.getTypedRuleContext(MIDLParser.Member_listContext,0)


        def getRuleIndex(self):
            return MIDLParser.RULE_struct_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStruct_type" ):
                listener.enterStruct_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStruct_type" ):
                listener.exitStruct_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStruct_type" ):
                return visitor.visitStruct_type(self)
            else:
                return visitor.visitChildren(self)




    def struct_type(self):

        localctx = MIDLParser.Struct_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_struct_type)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 86
            self.match(MIDLParser.T__4)
            self.state = 87
            self.match(MIDLParser.ID)
            self.state = 88
            self.match(MIDLParser.T__2)
            self.state = 89
            self.member_list()
            self.state = 90
            self.match(MIDLParser.T__3)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Member_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_spec(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MIDLParser.Type_specContext)
            else:
                return self.getTypedRuleContext(MIDLParser.Type_specContext,i)


        def declarators(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MIDLParser.DeclaratorsContext)
            else:
                return self.getTypedRuleContext(MIDLParser.DeclaratorsContext,i)


        def getRuleIndex(self):
            return MIDLParser.RULE_member_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMember_list" ):
                listener.enterMember_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMember_list" ):
                listener.exitMember_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMember_list" ):
                return visitor.visitMember_list(self)
            else:
                return visitor.visitChildren(self)




    def member_list(self):

        localctx = MIDLParser.Member_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_member_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 98
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 35184388866016) != 0):
                self.state = 92
                self.type_spec()
                self.state = 93
                self.declarators()
                self.state = 94
                self.match(MIDLParser.T__0)
                self.state = 100
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Type_specContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def scoped_name(self):
            return self.getTypedRuleContext(MIDLParser.Scoped_nameContext,0)


        def base_type_spec(self):
            return self.getTypedRuleContext(MIDLParser.Base_type_specContext,0)


        def struct_type(self):
            return self.getTypedRuleContext(MIDLParser.Struct_typeContext,0)


        def getRuleIndex(self):
            return MIDLParser.RULE_type_spec

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType_spec" ):
                listener.enterType_spec(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType_spec" ):
                listener.exitType_spec(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitType_spec" ):
                return visitor.visitType_spec(self)
            else:
                return visitor.visitChildren(self)




    def type_spec(self):

        localctx = MIDLParser.Type_specContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_type_spec)
        try:
            self.state = 104
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [6, 45]:
                self.enterOuterAlt(localctx, 1)
                self.state = 101
                self.scoped_name()
                pass
            elif token in [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]:
                self.enterOuterAlt(localctx, 2)
                self.state = 102
                self.base_type_spec()
                pass
            elif token in [5]:
                self.enterOuterAlt(localctx, 3)
                self.state = 103
                self.struct_type()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Scoped_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(MIDLParser.ID)
            else:
                return self.getToken(MIDLParser.ID, i)

        def getRuleIndex(self):
            return MIDLParser.RULE_scoped_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScoped_name" ):
                listener.enterScoped_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScoped_name" ):
                listener.exitScoped_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitScoped_name" ):
                return visitor.visitScoped_name(self)
            else:
                return visitor.visitChildren(self)




    def scoped_name(self):

        localctx = MIDLParser.Scoped_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_scoped_name)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 107
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==6:
                self.state = 106
                self.match(MIDLParser.T__5)


            self.state = 109
            self.match(MIDLParser.ID)
            self.state = 114
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==6:
                self.state = 110
                self.match(MIDLParser.T__5)
                self.state = 111
                self.match(MIDLParser.ID)
                self.state = 116
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Base_type_specContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def floating_pt_type(self):
            return self.getTypedRuleContext(MIDLParser.Floating_pt_typeContext,0)


        def integer_type(self):
            return self.getTypedRuleContext(MIDLParser.Integer_typeContext,0)


        def getRuleIndex(self):
            return MIDLParser.RULE_base_type_spec

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBase_type_spec" ):
                listener.enterBase_type_spec(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBase_type_spec" ):
                listener.exitBase_type_spec(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBase_type_spec" ):
                return visitor.visitBase_type_spec(self)
            else:
                return visitor.visitChildren(self)




    def base_type_spec(self):

        localctx = MIDLParser.Base_type_specContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_base_type_spec)
        try:
            self.state = 122
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [10, 11, 12]:
                self.enterOuterAlt(localctx, 1)
                self.state = 117
                self.floating_pt_type()
                pass
            elif token in [13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]:
                self.enterOuterAlt(localctx, 2)
                self.state = 118
                self.integer_type()
                pass
            elif token in [7]:
                self.enterOuterAlt(localctx, 3)
                self.state = 119
                self.match(MIDLParser.T__6)
                pass
            elif token in [8]:
                self.enterOuterAlt(localctx, 4)
                self.state = 120
                self.match(MIDLParser.T__7)
                pass
            elif token in [9]:
                self.enterOuterAlt(localctx, 5)
                self.state = 121
                self.match(MIDLParser.T__8)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Floating_pt_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return MIDLParser.RULE_floating_pt_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFloating_pt_type" ):
                listener.enterFloating_pt_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFloating_pt_type" ):
                listener.exitFloating_pt_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFloating_pt_type" ):
                return visitor.visitFloating_pt_type(self)
            else:
                return visitor.visitChildren(self)




    def floating_pt_type(self):

        localctx = MIDLParser.Floating_pt_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_floating_pt_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 124
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 7168) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Integer_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def signed_int(self):
            return self.getTypedRuleContext(MIDLParser.Signed_intContext,0)


        def unsigned_int(self):
            return self.getTypedRuleContext(MIDLParser.Unsigned_intContext,0)


        def getRuleIndex(self):
            return MIDLParser.RULE_integer_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInteger_type" ):
                listener.enterInteger_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInteger_type" ):
                listener.exitInteger_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInteger_type" ):
                return visitor.visitInteger_type(self)
            else:
                return visitor.visitChildren(self)




    def integer_type(self):

        localctx = MIDLParser.Integer_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_integer_type)
        try:
            self.state = 128
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [13, 14, 15, 16, 17, 18]:
                self.enterOuterAlt(localctx, 1)
                self.state = 126
                self.signed_int()
                pass
            elif token in [19, 20, 21, 22, 23]:
                self.enterOuterAlt(localctx, 2)
                self.state = 127
                self.unsigned_int()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Signed_intContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return MIDLParser.RULE_signed_int

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSigned_int" ):
                listener.enterSigned_int(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSigned_int" ):
                listener.exitSigned_int(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSigned_int" ):
                return visitor.visitSigned_int(self)
            else:
                return visitor.visitChildren(self)




    def signed_int(self):

        localctx = MIDLParser.Signed_intContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_signed_int)
        self._la = 0 # Token type
        try:
            self.state = 138
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 130
                _la = self._input.LA(1)
                if not(_la==13 or _la==14):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 131
                _la = self._input.LA(1)
                if not(_la==15 or _la==16):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 135
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [15]:
                    self.state = 132
                    self.match(MIDLParser.T__14)
                    self.state = 133
                    self.match(MIDLParser.T__14)
                    pass
                elif token in [17]:
                    self.state = 134
                    self.match(MIDLParser.T__16)
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 137
                self.match(MIDLParser.T__17)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Unsigned_intContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return MIDLParser.RULE_unsigned_int

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnsigned_int" ):
                listener.enterUnsigned_int(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnsigned_int" ):
                listener.exitUnsigned_int(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnsigned_int" ):
                return visitor.visitUnsigned_int(self)
            else:
                return visitor.visitChildren(self)




    def unsigned_int(self):

        localctx = MIDLParser.Unsigned_intContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_unsigned_int)
        try:
            self.state = 157
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,15,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 143
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [19]:
                    self.state = 140
                    self.match(MIDLParser.T__18)
                    self.state = 141
                    self.match(MIDLParser.T__12)
                    pass
                elif token in [20]:
                    self.state = 142
                    self.match(MIDLParser.T__19)
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 148
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [19]:
                    self.state = 145
                    self.match(MIDLParser.T__18)
                    self.state = 146
                    self.match(MIDLParser.T__14)
                    pass
                elif token in [21]:
                    self.state = 147
                    self.match(MIDLParser.T__20)
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 154
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [19]:
                    self.state = 150
                    self.match(MIDLParser.T__18)
                    self.state = 151
                    self.match(MIDLParser.T__14)
                    self.state = 152
                    self.match(MIDLParser.T__14)
                    pass
                elif token in [22]:
                    self.state = 153
                    self.match(MIDLParser.T__21)
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 156
                self.match(MIDLParser.T__22)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeclaratorsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def declarator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MIDLParser.DeclaratorContext)
            else:
                return self.getTypedRuleContext(MIDLParser.DeclaratorContext,i)


        def getRuleIndex(self):
            return MIDLParser.RULE_declarators

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeclarators" ):
                listener.enterDeclarators(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeclarators" ):
                listener.exitDeclarators(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeclarators" ):
                return visitor.visitDeclarators(self)
            else:
                return visitor.visitChildren(self)




    def declarators(self):

        localctx = MIDLParser.DeclaratorsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_declarators)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 159
            self.declarator()
            self.state = 164
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==24:
                self.state = 160
                self.match(MIDLParser.T__23)
                self.state = 161
                self.declarator()
                self.state = 166
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeclaratorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def simple_declarator(self):
            return self.getTypedRuleContext(MIDLParser.Simple_declaratorContext,0)


        def array_declarator(self):
            return self.getTypedRuleContext(MIDLParser.Array_declaratorContext,0)


        def getRuleIndex(self):
            return MIDLParser.RULE_declarator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeclarator" ):
                listener.enterDeclarator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeclarator" ):
                listener.exitDeclarator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeclarator" ):
                return visitor.visitDeclarator(self)
            else:
                return visitor.visitChildren(self)




    def declarator(self):

        localctx = MIDLParser.DeclaratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_declarator)
        try:
            self.state = 169
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,17,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 167
                self.simple_declarator()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 168
                self.array_declarator()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Simple_declaratorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(MIDLParser.ID, 0)

        def or_expr(self):
            return self.getTypedRuleContext(MIDLParser.Or_exprContext,0)


        def getRuleIndex(self):
            return MIDLParser.RULE_simple_declarator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimple_declarator" ):
                listener.enterSimple_declarator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimple_declarator" ):
                listener.exitSimple_declarator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimple_declarator" ):
                return visitor.visitSimple_declarator(self)
            else:
                return visitor.visitChildren(self)




    def simple_declarator(self):

        localctx = MIDLParser.Simple_declaratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_simple_declarator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 171
            self.match(MIDLParser.ID)
            self.state = 174
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==25:
                self.state = 172
                self.match(MIDLParser.T__24)
                self.state = 173
                self.or_expr()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Array_declaratorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(MIDLParser.ID, 0)

        def or_expr(self):
            return self.getTypedRuleContext(MIDLParser.Or_exprContext,0)


        def exp_list(self):
            return self.getTypedRuleContext(MIDLParser.Exp_listContext,0)


        def getRuleIndex(self):
            return MIDLParser.RULE_array_declarator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArray_declarator" ):
                listener.enterArray_declarator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArray_declarator" ):
                listener.exitArray_declarator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArray_declarator" ):
                return visitor.visitArray_declarator(self)
            else:
                return visitor.visitChildren(self)




    def array_declarator(self):

        localctx = MIDLParser.Array_declaratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_array_declarator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 176
            self.match(MIDLParser.ID)
            self.state = 177
            self.match(MIDLParser.T__25)
            self.state = 178
            self.or_expr()
            self.state = 179
            self.match(MIDLParser.T__26)
            self.state = 182
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==25:
                self.state = 180
                self.match(MIDLParser.T__24)
                self.state = 181
                self.exp_list()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Exp_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def or_expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MIDLParser.Or_exprContext)
            else:
                return self.getTypedRuleContext(MIDLParser.Or_exprContext,i)


        def getRuleIndex(self):
            return MIDLParser.RULE_exp_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExp_list" ):
                listener.enterExp_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExp_list" ):
                listener.exitExp_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExp_list" ):
                return visitor.visitExp_list(self)
            else:
                return visitor.visitChildren(self)




    def exp_list(self):

        localctx = MIDLParser.Exp_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_exp_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 184
            self.match(MIDLParser.T__25)
            self.state = 185
            self.or_expr()
            self.state = 190
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==24:
                self.state = 186
                self.match(MIDLParser.T__23)
                self.state = 187
                self.or_expr()
                self.state = 192
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 193
            self.match(MIDLParser.T__26)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Or_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def xor_expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MIDLParser.Xor_exprContext)
            else:
                return self.getTypedRuleContext(MIDLParser.Xor_exprContext,i)


        def getRuleIndex(self):
            return MIDLParser.RULE_or_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOr_expr" ):
                listener.enterOr_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOr_expr" ):
                listener.exitOr_expr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOr_expr" ):
                return visitor.visitOr_expr(self)
            else:
                return visitor.visitChildren(self)




    def or_expr(self):

        localctx = MIDLParser.Or_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_or_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 195
            self.xor_expr()
            self.state = 200
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==28:
                self.state = 196
                self.match(MIDLParser.T__27)
                self.state = 197
                self.xor_expr()
                self.state = 202
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Xor_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def and_expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MIDLParser.And_exprContext)
            else:
                return self.getTypedRuleContext(MIDLParser.And_exprContext,i)


        def getRuleIndex(self):
            return MIDLParser.RULE_xor_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXor_expr" ):
                listener.enterXor_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXor_expr" ):
                listener.exitXor_expr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXor_expr" ):
                return visitor.visitXor_expr(self)
            else:
                return visitor.visitChildren(self)




    def xor_expr(self):

        localctx = MIDLParser.Xor_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_xor_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 203
            self.and_expr()
            self.state = 208
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 204
                self.match(MIDLParser.T__28)
                self.state = 205
                self.and_expr()
                self.state = 210
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class And_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def shift_expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MIDLParser.Shift_exprContext)
            else:
                return self.getTypedRuleContext(MIDLParser.Shift_exprContext,i)


        def getRuleIndex(self):
            return MIDLParser.RULE_and_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnd_expr" ):
                listener.enterAnd_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnd_expr" ):
                listener.exitAnd_expr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAnd_expr" ):
                return visitor.visitAnd_expr(self)
            else:
                return visitor.visitChildren(self)




    def and_expr(self):

        localctx = MIDLParser.And_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_and_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 211
            self.shift_expr()
            self.state = 216
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==30:
                self.state = 212
                self.match(MIDLParser.T__29)
                self.state = 213
                self.shift_expr()
                self.state = 218
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Shift_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def add_expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MIDLParser.Add_exprContext)
            else:
                return self.getTypedRuleContext(MIDLParser.Add_exprContext,i)


        def getRuleIndex(self):
            return MIDLParser.RULE_shift_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShift_expr" ):
                listener.enterShift_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShift_expr" ):
                listener.exitShift_expr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShift_expr" ):
                return visitor.visitShift_expr(self)
            else:
                return visitor.visitChildren(self)




    def shift_expr(self):

        localctx = MIDLParser.Shift_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_shift_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 219
            self.add_expr()
            self.state = 224
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31 or _la==32:
                self.state = 220
                _la = self._input.LA(1)
                if not(_la==31 or _la==32):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 221
                self.add_expr()
                self.state = 226
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Add_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def mult_expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MIDLParser.Mult_exprContext)
            else:
                return self.getTypedRuleContext(MIDLParser.Mult_exprContext,i)


        def getRuleIndex(self):
            return MIDLParser.RULE_add_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdd_expr" ):
                listener.enterAdd_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdd_expr" ):
                listener.exitAdd_expr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAdd_expr" ):
                return visitor.visitAdd_expr(self)
            else:
                return visitor.visitChildren(self)




    def add_expr(self):

        localctx = MIDLParser.Add_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_add_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 227
            self.mult_expr()
            self.state = 232
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==33 or _la==34:
                self.state = 228
                _la = self._input.LA(1)
                if not(_la==33 or _la==34):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 229
                self.mult_expr()
                self.state = 234
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Mult_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unary_expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(MIDLParser.Unary_exprContext)
            else:
                return self.getTypedRuleContext(MIDLParser.Unary_exprContext,i)


        def getRuleIndex(self):
            return MIDLParser.RULE_mult_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMult_expr" ):
                listener.enterMult_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMult_expr" ):
                listener.exitMult_expr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMult_expr" ):
                return visitor.visitMult_expr(self)
            else:
                return visitor.visitChildren(self)




    def mult_expr(self):

        localctx = MIDLParser.Mult_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_mult_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 235
            self.unary_expr()
            self.state = 240
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 240518168576) != 0):
                self.state = 236
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 240518168576) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 237
                self.unary_expr()
                self.state = 242
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Unary_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def literal(self):
            return self.getTypedRuleContext(MIDLParser.LiteralContext,0)


        def getRuleIndex(self):
            return MIDLParser.RULE_unary_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnary_expr" ):
                listener.enterUnary_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnary_expr" ):
                listener.exitUnary_expr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnary_expr" ):
                return visitor.visitUnary_expr(self)
            else:
                return visitor.visitChildren(self)




    def unary_expr(self):

        localctx = MIDLParser.Unary_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_unary_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 244
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 300647710720) != 0):
                self.state = 243
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 300647710720) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 246
            self.literal()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTEGER(self):
            return self.getToken(MIDLParser.INTEGER, 0)

        def FLOATING_PT(self):
            return self.getToken(MIDLParser.FLOATING_PT, 0)

        def CHAR(self):
            return self.getToken(MIDLParser.CHAR, 0)

        def STRING(self):
            return self.getToken(MIDLParser.STRING, 0)

        def BOOLEAN(self):
            return self.getToken(MIDLParser.BOOLEAN, 0)

        def getRuleIndex(self):
            return MIDLParser.RULE_literal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLiteral" ):
                listener.enterLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLiteral" ):
                listener.exitLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLiteral" ):
                return visitor.visitLiteral(self)
            else:
                return visitor.visitChildren(self)




    def literal(self):

        localctx = MIDLParser.LiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_literal)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 248
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 34084860461056) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





